public List<Point> GetPoints(List<Point> points, double width, double distance, PointDistribution distribution)
{
    // Check if distance is a valid input
    if (distance <= 0)
    {
        throw new ArgumentException("Distance must be greater than 0");
    }

    // Calculate the maximum number of points that can fit within the given width
    int numberOfPoints = (int)(width / distance);

    // Prepare the result list
    List<Point> result = new List<Point>();

    // Find the pivot point, which is identified by the tag of 0
    var pivotPoint = points.Find(p => p.Tag == 0);

    // Check if a pivot point was found
    if (pivotPoint == null)
    {
        throw new Exception("No pivot point found (tag = 0)");
    }

    // Determine how to distribute the points based on the given distribution enum
    switch (distribution)
    {
        case PointDistribution.OnlyLeft:
            // If only left points are needed, filter the points to get only the ones with tags from 0 to -numberOfPoints.
            // Then sort them in ascending order by their tags.
            result = points.Where(p => p.Tag <= 0 && p.Tag >= -numberOfPoints).OrderBy(p => p.Tag).ToList();
            break;

        case PointDistribution.OnlyRight:
            // If only right points are needed, filter the points to get only the ones with tags from 0 to numberOfPoints.
            // Then sort them in ascending order by their tags.
            result = points.Where(p => p.Tag >= 0 && p.Tag <= numberOfPoints).OrderBy(p => p.Tag).ToList();
            break;

        case PointDistribution.Bilateral:
            // For bilateral distribution, the number of points is divided equally across both sides.
            // Therefore, halve the total number of points for the calculations.
            int halfNumberOfPoints = numberOfPoints / 2;

            var leftPoints = points.Where(p => p.Tag <= 0 && p.Tag >= -halfNumberOfPoints).OrderBy(p => p.Tag).ToList();
            var rightPoints = points.Where(p => p.Tag >= 0 && p.Tag <= halfNumberOfPoints).OrderBy(p => p.Tag).ToList();

            result.AddRange(leftPoints);
            result.AddRange(rightPoints);
            break;
    }

    // Return the result list of points
    return result;
}
