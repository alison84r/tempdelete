using System;
using System.Collections.Generic;

namespace SmoothedOffsetPolyline
{
    class Program
    {
        static void Main(string[] args)
        {
            List<Point> polyline = new List<Point> { new Point(0, 0), new Point(10, 10), new Point(20, 0), new Point(30, 10), new Point(40, 0) };
            double offset = 1.5;

            List<Point> offsetPolyline = OffsetPolyline(polyline, offset);
            List<Point> smoothedPolyline = SmoothPolyline(offsetPolyline);

            foreach (Point point in smoothedPolyline)
            {
                Console.WriteLine("(" + point.X + ", " + point.Y + ")");
            }
        }

       static List<Point> OffsetPolyline(List<Point> polyline, double offset)
        {
            List<Point> offsetPolyline = new List<Point>();

            for (int i = 0; i < polyline.Count - 1; i++)
            {
                Point p1 = polyline[i];
                Point p2 = polyline[i + 1];

                double dx = p2.X - p1.X;
                double dy = p2.Y - p1.Y;
                double length = Math.Sqrt(dx * dx + dy * dy);
                double angle = Math.Atan2(dy, dx);

                // Check if the offset direction is outward
                if (i == 0 || (polyline[i - 1].X - p1.X) * (p2.Y - p1.Y) - (polyline[i - 1].Y - p1.Y) * (p2.X - p1.X) >= 0)
                {
                    // Offset the polyline outward
                    Point offsetPoint1 = new Point(p1.X + offset * Math.Cos(angle + Math.PI / 2), p1.Y + offset * Math.Sin(angle + Math.PI / 2));
                    Point offsetPoint2 = new Point(p2.X + offset * Math.Cos(angle + Math.PI / 2), p2.Y + offset * Math.Sin(angle + Math.PI / 2));

                    offsetPolyline.Add(offsetPoint1);
                    offsetPolyline.Add(offsetPoint2);
                }
                else
                {
                    // Offset the polyline inward
                    Point offsetPoint1 = new Point(p1.X - offset * Math.Cos(angle + Math.PI / 2), p1.Y - offset * Math.Sin(angle + Math.PI / 2));
                    Point offsetPoint2 = new Point(p2.X - offset * Math.Cos(angle + Math.PI / 2), p2.Y - offset * Math.Sin(angle + Math.PI / 2));

                    offsetPolyline.Add(offsetPoint1);
                    offsetPolyline.Add(offsetPoint2);
                }
            }

            return offsetPolyline;
        }

        static List<Point> SmoothPolyline(List<Point> polyline)
        {
            int n = polyline.Count;
            List<Point> smoothedPolyline = new List<Point>();

            for (int i = 0; i < n; i++)
            {
                Point p0 = polyline[WrapIndex(i - 1, n)];
                Point p1 = polyline[i];
                Point p2 = polyline[WrapIndex(i + 1, n)];
                Point p3 = polyline[WrapIndex(i + 2, n)];

                for (double t = 0; t <= 1; t += 0.01)
                {
                    double x = CatmullRom(t, p0.X, p1.X, p2.X, p3.X);
                    double y = CatmullRom(t, p0.Y, p1.Y, p2.Y, p3.Y);
                    smoothedPolyline.Add(new Point(x, y));
                }
            }

            return smoothedPolyline;
        }

        static int WrapIndex(int i, int n)
        {
            return (i + n) % n;
        }

        static double CatmullRom(double t, double p0, double p1, double p2, double p3)
        {
            return 0.5 * (2 * p1 + (p2 - p0) * t + (2 * p0 - 5 * p1 + 4 * p2 - p3) * t * t + (p3 - 3 * p2 + 3 * p1 - p0) * t * t * t);
        }
    }

    class Point
    {
        public double X { get; set; }
        public double Y { get; set; }

